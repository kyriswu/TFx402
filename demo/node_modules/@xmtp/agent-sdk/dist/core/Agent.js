import EventEmitter from "node:events";
import fs from "node:fs";
import path from "node:path";
import { MarkdownCodec } from "@xmtp/content-type-markdown";
import { ReactionCodec } from "@xmtp/content-type-reaction";
import { ReadReceiptCodec } from "@xmtp/content-type-read-receipt";
import { RemoteAttachmentCodec } from "@xmtp/content-type-remote-attachment";
import { ReplyCodec } from "@xmtp/content-type-reply";
import { TransactionReferenceCodec } from "@xmtp/content-type-transaction-reference";
import { WalletSendCallsCodec } from "@xmtp/content-type-wallet-send-calls";
import { ApiUrls, Client, Dm, Group, isHexString, } from "@xmtp/node-sdk";
import { filter } from "../core/filter.js";
import { getInstallationInfo } from "../debug.js";
import { createSigner, createUser } from "../user/User.js";
import { AgentError, AgentStreamingError } from "./AgentError.js";
import { ClientContext } from "./ClientContext.js";
import { ConversationContext } from "./ConversationContext.js";
import { MessageContext } from "./MessageContext.js";
export class Agent extends EventEmitter {
    #client;
    #conversationsStream;
    #messageStream;
    #middleware = [];
    #errorMiddleware = [];
    #errors = Object.freeze({
        use: (...errorMiddleware) => {
            for (const emw of errorMiddleware) {
                if (Array.isArray(emw)) {
                    this.#errorMiddleware.push(...emw);
                }
                else if (typeof emw === "function") {
                    this.#errorMiddleware.push(emw);
                }
            }
            return this.#errors;
        },
    });
    #defaultErrorHandler = (currentError) => {
        const emittedError = currentError instanceof Error
            ? currentError
            : new AgentError(9999, `Unhandled error caught by default error middleware.`, currentError);
        this.emit("unhandledError", emittedError);
    };
    #isLocked = false;
    constructor({ client }) {
        super();
        this.#client = client;
    }
    static async create(signer, 
    // Note: we need to omit this so that "Client.create" can correctly infer the codecs.
    options) {
        const initializedOptions = { ...(options ?? {}) };
        initializedOptions.appVersion ??= "agent-sdk/alpha";
        const upgradedCodecs = [
            ...(initializedOptions.codecs ?? []),
            new MarkdownCodec(),
            new ReactionCodec(),
            new ReadReceiptCodec(),
            new ReplyCodec(),
            new RemoteAttachmentCodec(),
            new TransactionReferenceCodec(),
            new WalletSendCallsCodec(),
        ];
        if (process.env.XMTP_FORCE_DEBUG) {
            const loggingLevel = process.env.XMTP_FORCE_DEBUG_LEVEL || "warn" /* LogLevel.warn */;
            initializedOptions.debugEventsEnabled = true;
            initializedOptions.loggingLevel = loggingLevel;
            initializedOptions.structuredLogging = true;
        }
        const client = await Client.create(signer, {
            ...initializedOptions,
            codecs: upgradedCodecs,
        });
        const info = await getInstallationInfo(client);
        if (info.totalInstallations > 1 && info.isMostRecent) {
            console.warn(`[WARNING] You have "${info.totalInstallations}" installations. Installation ID "${info.installationId}" is the most recent. Make sure to persist and reload your installation data. If you exceed the installation limit, your Agent will stop working. Read more: https://docs.xmtp.org/agents/build-agents/local-database#installation-limits-and-revocation-rules`);
        }
        return new Agent({ client });
    }
    static async createFromEnv(
    // Note: we need to omit this so that "Client.create" can correctly infer the codecs.
    options) {
        const { XMTP_DB_DIRECTORY, XMTP_DB_ENCRYPTION_KEY, XMTP_ENV, XMTP_WALLET_KEY, } = process.env;
        if (!isHexString(XMTP_WALLET_KEY)) {
            throw new AgentError(1000, `XMTP_WALLET_KEY env is not in hex (0x) format.`);
        }
        const signer = createSigner(createUser(XMTP_WALLET_KEY));
        const initializedOptions = { ...(options ?? {}) };
        initializedOptions.dbEncryptionKey =
            typeof XMTP_DB_ENCRYPTION_KEY === "string"
                ? isHexString(XMTP_DB_ENCRYPTION_KEY)
                    ? XMTP_DB_ENCRYPTION_KEY
                    : `0x${XMTP_DB_ENCRYPTION_KEY}`
                : undefined;
        if (XMTP_ENV && Object.keys(ApiUrls).includes(XMTP_ENV)) {
            initializedOptions.env = XMTP_ENV;
        }
        if (typeof XMTP_DB_DIRECTORY === "string") {
            fs.mkdirSync(XMTP_DB_DIRECTORY, { recursive: true, mode: 0o700 });
            initializedOptions.dbPath = (inboxId) => {
                const dbPath = path.join(XMTP_DB_DIRECTORY, `xmtp-${inboxId}.db3`);
                console.info(`Saving local database to "${dbPath}"`);
                return dbPath;
            };
        }
        return this.create(signer, initializedOptions);
    }
    use(...middleware) {
        for (const mw of middleware) {
            if (Array.isArray(mw)) {
                this.#middleware.push(...mw);
            }
            else if (typeof mw === "function") {
                this.#middleware.push(mw);
            }
        }
        return this;
    }
    async #stopStreams() {
        try {
            await this.#conversationsStream?.end();
        }
        finally {
            this.#conversationsStream = undefined;
        }
        try {
            await this.#messageStream?.end();
        }
        finally {
            this.#messageStream = undefined;
        }
    }
    /**
     * Closes all existing streams and restarts the streaming system.
     */
    async #handleStreamError(error) {
        await this.#stopStreams();
        const recovered = await this.#runErrorChain(error, {
            client: this.#client,
        });
        if (recovered) {
            this.#isLocked = false;
            queueMicrotask(() => this.start());
        }
    }
    async start(options) {
        if (this.#isLocked || this.#conversationsStream || this.#messageStream)
            return;
        this.#isLocked = true;
        try {
            this.#conversationsStream = await this.#client.conversations.stream({
                ...options,
                onValue: async (conversation) => {
                    try {
                        if (!conversation) {
                            return;
                        }
                        this.emit("conversation", new ConversationContext({
                            conversation,
                            client: this.#client,
                        }));
                        if (conversation instanceof Group) {
                            this.emit("group", new ConversationContext({
                                conversation,
                                client: this.#client,
                            }));
                        }
                        else if (conversation instanceof Dm) {
                            this.emit("dm", new ConversationContext({
                                conversation,
                                client: this.#client,
                            }));
                        }
                    }
                    catch (error) {
                        const recovered = await this.#runErrorChain(new AgentError(1001, "Emitted value from conversation stream caused an error.", error), new ClientContext({ client: this.#client }));
                        if (!recovered)
                            await this.stop();
                    }
                },
                onError: async (error) => {
                    const recovered = await this.#runErrorChain(new AgentStreamingError(1002, "Error occured during conversation streaming.", error), new ClientContext({ client: this.#client }));
                    if (!recovered)
                        await this.stop();
                },
            });
            this.#messageStream = await this.#client.conversations.streamAllMessages({
                ...options,
                onValue: async (message) => {
                    try {
                        switch (true) {
                            case filter.isGroupUpdate(message):
                                await this.#processMessage(message, "group-update");
                                break;
                            case filter.isRemoteAttachment(message):
                                await this.#processMessage(message, "attachment");
                                break;
                            case filter.isReaction(message):
                                await this.#processMessage(message, "reaction");
                                break;
                            case filter.isReadReceipt(message):
                                await this.#processMessage(message, "read-receipt");
                                break;
                            case filter.isReply(message):
                                await this.#processMessage(message, "reply");
                                break;
                            case filter.isTransactionReference(message):
                                await this.#processMessage(message, "transaction-reference");
                                break;
                            case filter.isWalletSendCalls(message):
                                await this.#processMessage(message, "wallet-send-calls");
                                break;
                            case filter.isMarkdown(message):
                                await this.#processMessage(message, "markdown");
                                break;
                            case filter.isText(message):
                                await this.#processMessage(message, "text");
                                break;
                            default:
                                await this.#processMessage(message);
                                break;
                        }
                    }
                    catch (error) {
                        const recovered = await this.#runErrorChain(error, {
                            client: this.#client,
                        });
                        if (!recovered) {
                            await this.stop();
                        }
                        this.#isLocked = false;
                    }
                },
                onError: async (error) => {
                    const recovered = await this.#runErrorChain(new AgentStreamingError(1004, "Error occured during message streaming.", error), new ClientContext({ client: this.#client }));
                    if (!recovered)
                        await this.stop();
                },
            });
            this.emit("start", new ClientContext({ client: this.#client }));
            this.#isLocked = false;
        }
        catch (error) {
            await this.#handleStreamError(error);
        }
    }
    async #processMessage(message, topic = "unknownMessage") {
        // Skip messages with undefined content (failed to decode)
        if (!filter.hasContent(message)) {
            return;
        }
        // Skip messages from agent itself
        if (filter.fromSelf(message, this.#client)) {
            return;
        }
        const conversation = await this.#client.conversations.getConversationById(message.conversationId);
        if (!conversation) {
            throw new AgentError(1003, `Failed to process message ID "${message.id}" for conversation ID "${message.conversationId}" because the conversation could not be found.`);
        }
        const context = new MessageContext({
            message,
            conversation,
            client: this.#client,
        });
        await this.#runMiddlewareChain(context, topic);
    }
    async #runMiddlewareChain(context, topic = "unknownMessage") {
        const finalEmit = async () => {
            try {
                this.emit(topic, context);
                this.emit("message", context);
            }
            catch (error) {
                await this.#runErrorChain(error, context);
            }
        };
        const chain = this.#middleware.reduceRight((next, mw) => {
            return async () => {
                try {
                    await mw(context, next);
                }
                catch (error) {
                    const resume = await this.#runErrorChain(error, context);
                    if (resume) {
                        await next();
                    }
                    // Chain is not resuming, error is being swallowed
                }
            };
        }, finalEmit);
        await chain();
    }
    async #runErrorHandler(handler, context, error) {
        let settled = false;
        let flow = { kind: "stopped" };
        const next = (nextErr) => {
            if (settled)
                return;
            settled = true;
            flow =
                nextErr === undefined
                    ? { kind: "handled" }
                    : { kind: "continue", error: nextErr };
        };
        try {
            await handler(error, context, next);
            return flow;
        }
        catch (thrown) {
            if (settled) {
                return flow;
            }
            return { kind: "continue", error: thrown };
        }
    }
    async #runErrorChain(error, context) {
        const chain = [...this.#errorMiddleware, this.#defaultErrorHandler];
        let currentError = error;
        for (let i = 0; i < chain.length; i++) {
            const handler = chain[i];
            if (!handler)
                continue;
            const outcome = await this.#runErrorHandler(handler, context, currentError);
            switch (outcome.kind) {
                case "handled":
                    // Error was handled. Main middleware can continue.
                    return true;
                case "stopped":
                    // Error cannot be handled. Main middleware won't continue.
                    return false;
                case "continue":
                    // Error is passed to the next handler
                    currentError = outcome.error;
            }
        }
        // Reached end of chain without recovery
        return false;
    }
    get client() {
        return this.#client;
    }
    get errors() {
        return this.#errors;
    }
    async stop() {
        this.#isLocked = true;
        await this.#stopStreams();
        this.emit("stop", new ClientContext({ client: this.#client }));
        this.#isLocked = false;
    }
    createDmWithAddress(address, options) {
        return this.#client.conversations.newDmWithIdentifier({
            identifier: address,
            identifierKind: 0 /* IdentifierKind.Ethereum */,
        }, options);
    }
    createGroupWithAddresses(addresses, options) {
        const identifiers = addresses.map((address) => {
            return {
                identifier: address,
                identifierKind: 0 /* IdentifierKind.Ethereum */,
            };
        });
        return this.#client.conversations.newGroupWithIdentifiers(identifiers, options);
    }
    addMembersWithAddresses(group, addresses) {
        const identifiers = addresses.map((address) => {
            return {
                identifier: address,
                identifierKind: 0 /* IdentifierKind.Ethereum */,
            };
        });
        return group.addMembersByIdentifiers(identifiers);
    }
    get address() {
        return this.#client.accountIdentifier?.identifier;
    }
}
//# sourceMappingURL=Agent.js.map