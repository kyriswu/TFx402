import { ContentTypeText } from "@xmtp/content-type-text";
import { Agent } from "../core/Agent.js";
export const createMockMessage = (overrides) => {
    const { content, ...rest } = overrides;
    return {
        id: "mock-message-id",
        conversationId: "test-conversation-id",
        senderInboxId: "sender-inbox-id",
        contentType: ContentTypeText,
        ...rest,
        content,
    };
};
export const makeAgent = () => {
    return { agent: new Agent({ client: mockClient }), mockClient };
};
export const mockClient = {
    inboxId: "test-inbox-id",
    conversations: {
        sync: vi.fn().mockResolvedValue(undefined),
        stream: vi.fn().mockResolvedValue(undefined),
        streamAllMessages: vi.fn(),
        getConversationById: vi.fn().mockResolvedValue({
            send: vi.fn().mockResolvedValue(undefined),
        }),
    },
    preferences: {
        inboxStateFromInboxIds: vi.fn(),
    },
};
export const createMockStreamWithCallbacks = (messages) => {
    const mockStream = {
        end: vi.fn().mockResolvedValue(undefined),
        [Symbol.asyncIterator]: vi.fn(),
    };
    return vi
        .fn()
        .mockImplementation((options) => {
        // Simulate async message delivery
        queueMicrotask(() => {
            messages.forEach((message) => {
                options.onValue(message);
            });
        });
        return Promise.resolve(mockStream);
    });
};
export const createMockConversationStreamWithCallbacks = (conversations) => {
    const mockStream = {
        end: vi.fn().mockResolvedValue(undefined),
        [Symbol.asyncIterator]: vi.fn(),
    };
    return vi
        .fn()
        .mockImplementation((options) => {
        // Simulate async conversation delivery
        queueMicrotask(() => {
            conversations.forEach((conversation) => {
                options.onValue(conversation);
            });
        });
        return Promise.resolve(mockStream);
    });
};
export const flushMicrotasks = async () => {
    await new Promise((resolve) => setTimeout(resolve, 0));
};
export const expectMessage = (decodedMessage) => {
    return {
        message: expect.objectContaining(decodedMessage),
    };
};
//# sourceMappingURL=TestUtil.js.map